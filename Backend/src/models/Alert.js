import mongoose from 'mongoose';

const alertSchema = new mongoose.Schema(
  {
    type: {
      type: String,
      enum: [
        'LOW_STOCK',
        'STOCKOUT_RISK', 
        'OVERSTOCKED',
        'ABC_RECLASSIFICATION',
        'SLOW_MOVING',
        'LAYOUT_OPTIMIZATION',
        'COST_THRESHOLD',
        'DISPATCH_DELAY',
        'SYSTEM_ALERT'
      ],
      required: true,
    },
    priority: {
      type: String,
      enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
      default: 'MEDIUM',
    },
    title: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
    details: {
      type: Object,
      default: {},
    },
    relatedEntity: {
      entityType: {
        type: String,
        enum: ['SKU', 'LAYOUT', 'LOCATION', 'DISPATCH', 'USER', 'SYSTEM'],
      },
      entityId: {
        type: mongoose.Schema.Types.ObjectId,
        refPath: 'relatedEntity.entityType',
      },
    },
    status: {
      type: String,
      enum: ['ACTIVE', 'ACKNOWLEDGED', 'RESOLVED', 'DISMISSED'],
      default: 'ACTIVE',
    },
    threshold: {
      value: { type: Number },
      condition: { 
        type: String, 
        enum: ['LESS_THAN', 'GREATER_THAN', 'EQUALS', 'BETWEEN'] 
      },
      unit: { type: String },
    },
    assignedTo: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
    acknowledgedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
    acknowledgedAt: {
      type: Date,
    },
    resolvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
    resolvedAt: {
      type: Date,
    },
    autoGenerated: {
      type: Boolean,
      default: true,
    },
    expiresAt: {
      type: Date,
    },
    actionTaken: {
      type: String,
    },
    tags: [{
      type: String,
    }],
    metadata: {
      source: { type: String, default: 'SYSTEM' },
      frequency: { 
        type: String, 
        enum: ['ONE_TIME', 'RECURRING', 'CONDITION_BASED'],
        default: 'ONE_TIME' 
      },
      lastTriggered: { type: Date },
      triggerCount: { type: Number, default: 1 },
    }
  },
  {
    timestamps: true,
  }
);

// Index for efficient querying
alertSchema.index({ status: 1, priority: 1, createdAt: -1 });
alertSchema.index({ 'relatedEntity.entityType': 1, 'relatedEntity.entityId': 1 });
alertSchema.index({ assignedTo: 1, status: 1 });
alertSchema.index({ type: 1, status: 1 });

// Virtual for checking if alert is overdue
alertSchema.virtual('isOverdue').get(function() {
  if (!this.expiresAt) return false;
  return this.expiresAt < new Date() && this.status === 'ACTIVE';
});

// Method to acknowledge alert
alertSchema.methods.acknowledge = function(userId) {
  this.status = 'ACKNOWLEDGED';
  this.acknowledgedBy = userId;
  this.acknowledgedAt = new Date();
  return this.save();
};

// Method to resolve alert
alertSchema.methods.resolve = function(userId, actionTaken) {
  this.status = 'RESOLVED';
  this.resolvedBy = userId;
  this.resolvedAt = new Date();
  if (actionTaken) this.actionTaken = actionTaken;
  return this.save();
};

// Static method to create low stock alert
alertSchema.statics.createLowStockAlert = function(skuId, currentStock, threshold) {
  return this.create({
    type: 'LOW_STOCK',
    priority: 'HIGH',
    title: 'Low Stock Alert',
    message: `Stock level below threshold (${currentStock} < ${threshold})`,
    relatedEntity: {
      entityType: 'SKU',
      entityId: skuId
    },
    threshold: {
      value: threshold,
      condition: 'LESS_THAN',
      unit: 'units'
    },
    details: {
      currentStock,
      threshold
    },
    tags: ['inventory', 'stock-management'],
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
  });
};

// Static method to create stockout risk alert
alertSchema.statics.createStockoutRiskAlert = function(skuId, daysToStockout, riskLevel) {
  const priority = riskLevel === 'Critical' ? 'CRITICAL' : 
                  riskLevel === 'High' ? 'HIGH' : 'MEDIUM';
  
  return this.create({
    type: 'STOCKOUT_RISK',
    priority,
    title: `${riskLevel} Stockout Risk`,
    message: `Predicted stockout in ${Math.round(daysToStockout)} days`,
    relatedEntity: {
      entityType: 'SKU',
      entityId: skuId
    },
    details: {
      daysToStockout,
      riskLevel
    },
    tags: ['inventory', 'forecasting', 'risk'],
    expiresAt: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000) // 3 days
  });
};

const Alert = mongoose.model('Alert', alertSchema);

export default Alert;
